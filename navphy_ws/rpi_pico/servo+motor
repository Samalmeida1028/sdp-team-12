"""
Read the Serial port to receive color data for the neopixel.


This uses the optional second serial port available in Circuitpython 7.x
Activate it in the boot.py file with the following code

import usb_cdc
usb_cdc.enable(console=True, data=True)
  # Initialize the rclpy library

Some boards might require disabling USB endpoints to enable the data port.
"""

import usb_cdc
import time
import board
import pwmio
from adafruit_motor import servo
import json
import motor_controller
from motor_controller import DFR0601, ChassisController

################################################################
# select the serial Data port
################################################################

serial = usb_cdc.data
pwm1 = pwmio.PWMOut(board.GP0, duty_cycle=2 ** 15, frequency=50)
pwm2 = pwmio.PWMOut(board.GP1, duty_cycle=2 ** 12, frequency=50)
my_servoy = servo.Servo(pwm2)
my_servox = servo.Servo(pwm1)
center = 90
my_servox.angle = center
my_servoy.angle = center

tempx = center
tempy = center
data_inx,data_iny = center,center
integral_x = 0
integral_y = 0
p_gain = .11
d_gain = 7.8
i_gain = 1.1




INA1 = board.GP21
INB1 = board.GP20
PWM1 = board.GP19

INA2 = board.GP26
INB2 = board.GP27
PWM2 = board.GP28

INA3 = board.GP7
INB3 = board.GP6
PWM3 = board.GP8

INA4 = board.GP3
INB4 = board.GP5
PWM4 = board.GP4

driver1 = DFR0601(PWM1,INA1,INB1,PWM2,INA2, INB2,80000)
driver2 = DFR0601(PWM3,INA3,INB3,PWM4,INA4, INB4,80000)

chassis_controls = ChassisController(driver1,driver2)

flag = 1
count = 0

while True:
    # read the secondary serial line by line when there's data
    # note that this assumes that the host always sends a full line
    if serial.in_waiting > 0:
        count = 0
        data_in = serial.readline()
        if(data_in):
            translation = json.loads(data_in.decode('utf-8'))
            if(translation[0]**2+translation[1]**2 > 100):
                driver1.stop()
                driver2.stop()
                flag = 0
                if my_servox.angle is not 180 and my_servox.angle is not 0:
                    integral_x += (my_servox.angle-tempx) * .01
                if my_servoy.angle is not 180 and my_servoy is not 0:
                    integral_y += (my_servoy.angle - tempy) * .01
                derivative_x = ((my_servox.angle-tempx)*3) 
                derivative_y = ((my_servoy.angle-tempy)*3)
                data_inx += ((translation[0] * (180/1920))*p_gain) + derivative_x* d_gain + integral_x*i_gain
                data_iny -= ((translation[1] * (180/1080))*p_gain*.66) + derivative_y*d_gain + integral_y*i_gain
            elif translation[0]**2+translation[1]**2 < 100:
                angle =  my_servox.angle
                # print(angle)
                serial.write(bytearray(json.dumps(angle), "utf-8"))
                # if flag == 0:
                #     flag = 1
                # print("for")
                    # time.sleep(1)
                    # print("stop")
            if(translation[0] < 100):
                driver1angle = 90-my_servox.angle
                driver2angle = -driver1angle
                print(driver1angle,driver2angle)

                if(driver1angle > 0):
                    driver1.forward(max(int(17000*(driver1angle)/17),10500))
                else:
                    driver1.backward(max(int(17000*abs(driver1angle)/17),10500))
                if(driver2angle > 0):
                    driver2.forward(max(int(17000*(driver2angle)/17),10500))
                else:
                    driver2.backward(max(int(17000*abs(driver2angle)/17),10500))
            elif(translation[0] > 500):
                driver1.stop()
                driver2.stop()



            my_servox.angle = min(180,max(0,data_inx))
            my_servoy.angle = min(120,max(0,data_iny))

            tempx = my_servox.angle
            tempy = my_servoy.angle   
        else:
            # print("hi")
            
            my_servox.angle = min(180,max(0,tempx))
            my_servoy.angle = min(120,max(0,tempy))
    else:
        count += 1
        # print(count)
        if(count > 3000):
            driver1.stop()
            driver2.stop()
                